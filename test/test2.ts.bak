/* import { ethers } from 'ethers';
import * from 'merkle-tree-solidity';

interface Transaction {
  target: string;
  data: string;
  value: string;
  gasLimit: number;
}

async function batchAndStoreTransactions(
  transactions: Transaction[],
  contract: ethers.Contract,
  privateKey: string
): Promise<void> {
  const provider = contract.provider!;
  const signer = new ethers.Wallet(privateKey, provider);
  const gasPrice = await provider.getGasPrice();

  const batchedTxData: string[] = [];
  let totalGasLimit = 0;

  for (const tx of transactions) {
    const txData = contract.interface.encodeFunctionData('executeTransaction', [
      tx.target,
      tx.value,
      tx.data,
    ]);
    batchedTxData.push(txData);
    totalGasLimit += tx.gasLimit;
  }

  const tx = {
    to: contract.address,
    gasLimit: totalGasLimit,
    gasPrice: gasPrice.mul(2),
    data: '0x' + batchedTxData.join(''),
  };

  const signedTx = await signer.signTransaction(tx);
  const txReceipt = await provider.sendTransaction(signedTx);
  await txReceipt.wait();

  const leafData: string[] = [];
  for (const txData of batchedTxData) {
    leafData.push(ethers.utils.solidityKeccak256(['bytes'], [txData]).toString());
  }

  const tree = new MerkleTree(leafData, ethers.utils.solidityKeccak256(['bytes'], ['0x']));
  const root = '0x' + tree.getRoot().toString('hex');

  await contract.storeMerkleRoot(root);
}

import { ethers as ethersjs } from 'ethers';
import { MerkleTree } from 'merkletreejs';

interface Transaction {
  target: string;
  data: string;
  value: string;
  gasLimit: number;
}

async function batchAndStoreTransactions(
  transactions: Transaction[],
  contract: ethersjs.Contract,
  privateKey: string
): Promise<void> {
  const provider = contract.provider!;
  const signer = new ethersjs.Wallet(privateKey, provider);
  const gasPrice = await provider.getGasPrice();

  const batchedTxData: string[] = [];
  let totalGasLimit = 0;

  for (const tx of transactions) {
    const txData = contract.interface.encodeFunctionData('executeTransaction', [
      tx.target,
      tx.value,
      tx.data,
    ]);
    batchedTxData.push(txData);
    totalGasLimit += tx.gasLimit;
  }

  const tx = {
    to: contract.address,
    gasLimit: totalGasLimit,
    gasPrice: gasPrice.mul(2),
    data: '0x' + batchedTxData.join(''),
  };

  const signedTx = await signer.signTransaction(tx);
  const txReceipt = await provider.sendTransaction(signedTx);
  await txReceipt.wait();

  const leafData: string[] = [];
  for (const txData of batchedTxData) {
    leafData.push(ethersjs.utils.keccak256(ethersjs.utils.defaultAbiCoder.encode(['bytes'], [txData])).toString());
  }

  const tree = new MerkleTree(leafData);
  const root = '0x' + tree.getHexRoot();

  await contract.storeMerkleRoot(root);
}


const { expect } = require("chai");

describe("MerkleRootStorage contract", function () {
  it("should batch and store transactions", async function () {
    const [owner, account1] = await ethersjs.getSigners();
    const MerkleRootStorage = await ethersjs.getContractFactory("MerkleRootStorage");
    const merkleRootStorage = await MerkleRootStorage.connect(owner).deploy();

    const transactions = [
      {
        target: account1.address,
        data: "0x",
        value: "0",
        gasLimit: 100000,
      },
      {
        target: account1.address,
        data: "0x",
        value: "0",
        gasLimit: 100000,
      },
    ];
    const privateKey = "0x0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef";
    await merkleRootStorage.connect(owner).storeMerkleRoot("0x00000000000000000000000000000001");

    await expect(batchAndStoreTransactions(transactions, merkleRootStorage, privateKey)).to.not.be.rejected;

    const leaves = [];
    for (const tx of transactions) {
      const txData = merkleRootStorage.interface.encodeFunctionData("executeTransaction", [
        tx.target,
        tx.value,
        tx.data,
      ]);
      leaves.push(ethersjs.utils.keccak256(ethersjs.utils.defaultAbiCoder.encode(["bytes"], [txData])));
    }
    const tree = new MerkleTree(leaves);
    const root = "0x" + tree.getHexRoot();

    expect(await merkleRootStorage.merkleRootCompact()).to.equal("0x00000000000000000000000000000001");
    expect(await merkleRootStorage.verified(root)).to.be.true;
  });
});
 */
